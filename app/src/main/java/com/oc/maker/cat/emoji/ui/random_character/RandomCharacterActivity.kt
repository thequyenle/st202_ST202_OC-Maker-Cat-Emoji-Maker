package com.oc.maker.cat.emoji.ui.random_character

import android.app.ActivityOptions
import android.content.Intent
import android.view.LayoutInflater
import android.view.View
import android.view.WindowManager
import androidx.activity.viewModels
import androidx.lifecycle.lifecycleScope
import com.lvt.ads.util.Admob
import com.oc.maker.cat.emoji.R
import com.oc.maker.cat.emoji.ui.customize.CustomizeCharacterActivity
import com.oc.maker.cat.emoji.ui.customize.CustomizeCharacterViewModel
import com.oc.maker.cat.emoji.ui.home.DataViewModel
import com.oc.maker.cat.emoji.core.base.BaseActivity
import com.oc.maker.cat.emoji.core.extensions.dLog
import com.oc.maker.cat.emoji.core.extensions.eLog
import com.oc.maker.cat.emoji.core.extensions.handleBackLeftToRight
import com.oc.maker.cat.emoji.core.extensions.hideNavigation
import com.oc.maker.cat.emoji.core.extensions.loadNativeCollabAds
import com.oc.maker.cat.emoji.core.extensions.setImageActionBar
import com.oc.maker.cat.emoji.core.extensions.setTextActionBar
import com.oc.maker.cat.emoji.core.extensions.showInterAll
import com.oc.maker.cat.emoji.core.extensions.tap
import com.oc.maker.cat.emoji.core.extensions.startIntentRightToLeft
import com.oc.maker.cat.emoji.core.extensions.visible
import com.oc.maker.cat.emoji.core.helper.InternetHelper
import com.oc.maker.cat.emoji.core.helper.MediaHelper
import com.oc.maker.cat.emoji.core.utils.key.IntentKey
import com.oc.maker.cat.emoji.core.utils.key.ValueKey
import com.oc.maker.cat.emoji.data.model.custom.SuggestionModel
import com.oc.maker.cat.emoji.databinding.ActivityRandomCharacterBinding
import com.oc.maker.cat.emoji.dialog.YesNoDialog
import kotlinx.coroutines.CoroutineExceptionHandler
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.async
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlin.collections.get
import kotlin.getValue
import kotlin.text.compareTo

class RandomCharacterActivity : BaseActivity<ActivityRandomCharacterBinding>() {
    private val viewModel: RandomCharacterViewModel by viewModels()
    private val dataViewModel: DataViewModel by viewModels()
    private val customizeCharacterViewModel: CustomizeCharacterViewModel by viewModels()
    private val randomCharacterAdapter by lazy { RandomCharacterAdapter(this) }

    override fun setViewBinding(): ActivityRandomCharacterBinding {
        return ActivityRandomCharacterBinding.inflate(LayoutInflater.from(this))
    }

    override fun initView() {
        dataViewModel.ensureData(this)
    }

    override fun dataObservable() {
        lifecycleScope.launch {
            lifecycleScope.launch {
                dataViewModel.allData.collect { data ->
                    if (data.isNotEmpty()) {
                        initData()
                    }
                }
            }
        }
    }

    override fun viewListener() {
        binding.apply {
            actionBar.btnActionBarLeft.tap { showInterAll{handleBackLeftToRight()} }

        }

        randomCharacterAdapter.onItemClick = { model -> handleItemClick(model)}

    }

    override fun initActionBar() {
        binding.actionBar.apply {
            setImageActionBar(btnActionBarLeft, R.drawable.ic_back)
            setTextActionBar(tvCenter, getString(R.string.quick_maker_in))
            tvCenter.isSelected =true
        }
    }

    private fun initData() {
        val handleExceptionCoroutine = CoroutineExceptionHandler { _, throwable ->
            eLog("initData: ${throwable.message}")
            CoroutineScope(Dispatchers.Main).launch {
                dismissLoading()
                val dialogExit = YesNoDialog(this@RandomCharacterActivity, R.string.error, R.string.an_error_occurred)
                dialogExit.show()
                dialogExit.onNoClick = {
                    dialogExit.dismiss()
                    finish()
                }
                dialogExit.onYesClick = {
                    dialogExit.dismiss()
                    hideNavigation()
                    startIntentRightToLeft(
                        RandomCharacterActivity::class.java, customizeCharacterViewModel.positionSelected
                    )
                    finish()
                }
            }
        }

        CoroutineScope(SupervisorJob() + Dispatchers.IO + handleExceptionCoroutine).launch {
            showLoading()
            // Get data from list
            val deferred1 = async {
                val timeStart1 = System.currentTimeMillis()
                val hasInternet = InternetHelper.isInternetAvailable(this@RandomCharacterActivity)

                // Filter data: if no internet, show only local data (isFromAPI = false)
                val filteredData = if (hasInternet) {
                    dataViewModel.allData.value
                } else {
                    dataViewModel.allData.value.filter { !it.isFromAPI }
                }

                dLog("==========================================================")
                dLog("⏱️ TIMING LOG - RandomCharacter Generation Started")
                dLog("RandomCharacter: Starting to process ${filteredData.size} characters")
                dLog("Total data available: ${dataViewModel.allData.value.size}")
                dLog("Has Internet: $hasInternet")
                dLog("Filtered to local only: ${!hasInternet}")
                dLog("==========================================================")

                for (i in 0 until filteredData.size) {
                    try {
                        val charStartTime = System.currentTimeMillis()
                        dLog("---------- Processing Character $i ----------")
                        val currentData = filteredData[i]
                        customizeCharacterViewModel.positionSelected = dataViewModel.allData.value.indexOf(currentData)
                        dLog("Character name: ${currentData.dataName}")
                        dLog("Avatar path: ${currentData.avatar}")
                        dLog("Layer count: ${currentData.layerList.size}")
                        dLog("Is from API: ${currentData.isFromAPI}")

                        val setupStartTime = System.currentTimeMillis()
                        customizeCharacterViewModel.setDataCustomize(currentData)
                        customizeCharacterViewModel.updateAvatarPath(currentData.avatar)

                        customizeCharacterViewModel.resetDataList()
                        customizeCharacterViewModel.addValueToItemNavList()
                        customizeCharacterViewModel.setItemColorDefault()
                        customizeCharacterViewModel.setBottomNavigationListDefault()
                        val setupTime = System.currentTimeMillis() - setupStartTime
                        dLog("⏱️ Character $i - Setup time: ${setupTime}ms")

                        val randomStartTime = System.currentTimeMillis()
                        for (j in 0 until ValueKey.RANDOM_QUANTITY) {
                            val itemStartTime = System.currentTimeMillis()
                            customizeCharacterViewModel.setClickRandomFullLayer()
                            val suggestion = customizeCharacterViewModel.getSuggestionList()
                            val itemTime = System.currentTimeMillis() - itemStartTime
                            if (j == 0 || j == ValueKey.RANDOM_QUANTITY - 1) {
                                dLog("⏱️ Character $i - Random item $j time: ${itemTime}ms")
                            }
                            viewModel.updateRandomList(suggestion)
                        }
                        val randomTime = System.currentTimeMillis() - randomStartTime
                        dLog("⏱️ Character $i - Total random generation time (20 items): ${randomTime}ms")
                        dLog("⏱️ Character $i - Average per item: ${randomTime / ValueKey.RANDOM_QUANTITY}ms")

                        val charTotalTime = System.currentTimeMillis() - charStartTime
                        dLog("⏱️ Character $i - TOTAL TIME: ${charTotalTime}ms")
                        dLog("✓ Character $i completed successfully")
                    } catch (e: Exception) {
                        eLog("✗ ERROR processing character $i: ${e.message}")
                        e.printStackTrace()
                    }
                }

                val shuffleStartTime = System.currentTimeMillis()
                viewModel.upsideDownList()
                val shuffleTime = System.currentTimeMillis() - shuffleStartTime
                dLog("⏱️ Shuffle time: ${shuffleTime}ms")

                val totalTime = System.currentTimeMillis() - timeStart1
                dLog("==========================================================")
                dLog("⏱️ TIMING LOG - RandomCharacter Generation Completed")
                dLog("Total time: ${totalTime}ms")
                dLog("Final random list size: ${viewModel.randomList.size}")
                dLog("Average time per character: ${totalTime / filteredData.size}ms")
                dLog("==========================================================")
                return@async true
            }

            withContext(Dispatchers.Main) {
                if (deferred1.await()) {
                    dismissLoading()
                    initRcv()
                }
            }
        }
    }

    private fun initRcv() {
        val rcvStartTime = System.currentTimeMillis()
        binding.rcvRandomCharacter.apply {
            adapter = randomCharacterAdapter
            itemAnimator = null

            // ✅ PERFORMANCE OPTIMIZATIONS
            // Cache more ViewHolders to avoid recreating them
            setItemViewCacheSize(20)

            // Use a shared RecycledViewPool for better performance
            setRecycledViewPool(androidx.recyclerview.widget.RecyclerView.RecycledViewPool().apply {
                setMaxRecycledViews(0, 30)
            })

            // Enable drawing cache (deprecated but can help on older devices)
            isDrawingCacheEnabled = true
            setHasFixedSize(true) // All items have the same size

        }
        dLog("==========================================================")
        dLog("⏱️ TIMING LOG - RecyclerView Setup")
        dLog("initRcv: Submitting ${viewModel.randomList.size} items to adapter")
        viewModel.randomList.forEachIndexed { index, item ->
            if (index < 3 || index >= viewModel.randomList.size - 1) {
                dLog("Item $index: Avatar=${item.avatarPath}, Layers=${item.pathSelectedList.size}, Cached=${item.pathInternalRandom.isNotEmpty()}")
            }
        }

        val submitStartTime = System.currentTimeMillis()
        randomCharacterAdapter.submitList(viewModel.randomList)
        val submitTime = System.currentTimeMillis() - submitStartTime
        val rcvTotalTime = System.currentTimeMillis() - rcvStartTime

        dLog("⏱️ submitList() time: ${submitTime}ms")
        dLog("⏱️ Total initRcv() time: ${rcvTotalTime}ms")
        dLog("==========================================================")
    }

    private fun handleItemClick(model: SuggestionModel) {
        customizeCharacterViewModel.positionSelected = dataViewModel.allData.value.indexOfFirst { it.avatar == model.avatarPath }
        // ✅ FIX: Use isFromAPI flag from character data instead of position
        val selectedCharacter = dataViewModel.allData.value.getOrNull(customizeCharacterViewModel.positionSelected)
        viewModel.setIsDataAPI(selectedCharacter?.isFromAPI ?: false)
        viewModel.checkDataInternet(this@RandomCharacterActivity) {
            lifecycleScope.launch {
                showLoading()
                withContext(Dispatchers.IO) {
                    MediaHelper.writeModelToFile(this@RandomCharacterActivity, ValueKey.SUGGESTION_FILE_INTERNAL, model)
                }
                val intent = Intent(this@RandomCharacterActivity, CustomizeCharacterActivity::class.java)
                intent.putExtra(IntentKey.INTENT_KEY, customizeCharacterViewModel.positionSelected)
                intent.putExtra(IntentKey.STATUS_FROM_KEY, ValueKey.SUGGESTION)
                val option = ActivityOptions.makeCustomAnimation(
                    this@RandomCharacterActivity,
                    R.anim.slide_out_left,
                    R.anim.slide_in_right
                )
                dismissLoading()
                showInterAll { startActivity(intent, option.toBundle()) }
            }
        }
    }
//
    fun initNativeCollab() {
    Admob.getInstance().loadNativeCollapNotBanner(this,getString(R.string.native_cl_quickMix), binding.flNativeCollab)
    }

    override fun initAds() {
        initNativeCollab()
    }

    override fun onRestart() {
        super.onRestart()
        initNativeCollab()
    }

    override fun onWindowFocusChanged(hasFocus: Boolean) {
        super.onWindowFocusChanged(hasFocus)
        if (hasFocus) {
            applyUiCustomize()
            hideNavigation(true)

            window.decorView.removeCallbacks(reHideRunnable)
            window.decorView.postDelayed(reHideRunnable, 2000)
        } else {
            window.decorView.removeCallbacks(reHideRunnable)
        }
    }

    private val reHideRunnable = Runnable {
        applyUiCustomize()
        hideNavigation(true)
    }

    @Suppress("DEPRECATION")
    private fun applyUiCustomize() {
        // Cho phép app tự vẽ màu system bar
        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)

        // Transparent status bar
        window.statusBarColor = android.graphics.Color.TRANSPARENT
        window.navigationBarColor = android.graphics.Color.TRANSPARENT

        // Flags
        window.decorView.systemUiVisibility =
            View.SYSTEM_UI_FLAG_LAYOUT_STABLE or
                    View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or
                    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or
                    View.SYSTEM_UI_FLAG_HIDE_NAVIGATION or
                    View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
        View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR
        // nếu muốn icon status bar đen thì thêm:
        // or View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR
    }

    override fun onDestroy() {
        super.onDestroy()
        // ✅ Cancel all pending image processing jobs to prevent memory leaks
        randomCharacterAdapter.cancelAllJobs()
    }
}